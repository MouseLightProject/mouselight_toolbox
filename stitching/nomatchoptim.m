function [targets_at_cpg_k_indices_3_and_4, ...
          neighbor_targets_at_cpg_k_indices_1_and_2, ...
          new_k0_from_cpg_k_index, ...
          new_neighbor_tile_k0_from_cpg_k_index] = ...
    nomatchoptim(tile_index, ...
                 params, ...
                 neighbor_tile_index, ...
                 affine_transform_from_tile_index, ...
                 match_z_statistics_from_tile_index, ...
                 old_k0_from_cpg_k_index, ...
                 old_neighbor_tile_k0_from_cpg_k_index, ...
                 field_corrected_cpg_ij0s, ...
                 Fx_layer, ...
                 Fy_layer, ...
                 Fz_layer, ...
                 Fx_next_layer, ...
                 Fy_next_layer, ...
                 Fz_next_layer, ...
                 default_k0_from_cpg_k_index)

    % The neighbor_tile_index shold be the index of the z+1 tile, or nan if there is no such tile.                              
                 
    % In all that follows, "CPG" means "control point grid".
             
    % Extract parameters             
    htop = params.htop ;  % the offset from the 2nd CPG z-plane to the 1st
    do_correct_targets = true ;  % I guess can be set to false for debugging?

    % Get the affine transforms for this tile and the neighbor tile
    affine_transform = affine_transform_from_tile_index(:,:,tile_index) ;
    neighbor_affine_transform = affine_transform_from_tile_index(:,:,neighbor_tile_index) ;

    % Compute the targets for 3rd CPG z-plane (for this tile)
    default_k0_at_cpg_k_index_3 = default_k0_from_cpg_k_index(3) ;
    targets_at_cpg_k_index_3 = ...
        corrected_targets_for_single_cpg_k_plane(default_k0_at_cpg_k_index_3, ...
                                                 field_corrected_cpg_ij0s, ...
                                                 affine_transform, ...
                                                 Fx_layer, ...
                                                 Fy_layer, ...
                                                 Fz_layer, ...
                                                 do_correct_targets) ;

    % Compute the targets for 4th CPG z-plane (for this tile)
    default_k0_at_cpg_k_index_4 = default_k0_from_cpg_k_index(4) ;
    targets_at_cpg_k_index_4 = ...
        corrected_targets_for_single_cpg_k_plane(default_k0_at_cpg_k_index_4, ...
                                                 field_corrected_cpg_ij0s, ...
                                                 affine_transform, ...
                                                 Fx_layer, ...
                                                 Fy_layer, ...
                                                 Fz_layer, ...
                                                 do_correct_targets) ;

    % Collect the targets for the self tile for return
    targets_at_cpg_k_indices_3_and_4 = [ targets_at_cpg_k_index_3 ; targets_at_cpg_k_index_4 ] ;

    % Search to find a good level for CPG plane 2 in the neighbor tile
    % Want the z values in the rendered space to be less than those of the plane 4
    % targets for the self tile.
    other_min_match_z_from_tile_index = match_z_statistics_from_tile_index(:,6) ;
    other_max_match_z_from_tile_index = match_z_statistics_from_tile_index(:,8) ;    
    max_other_max_match_z = max(other_max_match_z_from_tile_index(other_max_match_z_from_tile_index<150)) ; 
        % added a hard cap at 150 to prevent artifacts due to curation overwrite mistakes
    min_other_min_match_z = min(other_min_match_z_from_tile_index) ;
    for neighbor_tile_new_k0_at_cpg_k_index_2 = max_other_max_match_z-1 : -1 : max(1,min(max_other_max_match_z-1,min_other_min_match_z)) ,
        neighbor_targets_at_cpg_k_index_2 = ...
            corrected_targets_for_single_cpg_k_plane(neighbor_tile_new_k0_at_cpg_k_index_2, ...
                                                     field_corrected_cpg_ij0s, ...
                                                     neighbor_affine_transform, ...
                                                     Fx_next_layer, ...
                                                     Fy_next_layer, ...
                                                     Fz_next_layer, ...
                                                     do_correct_targets) ;

        % make sure that there is overlap for all control points
        if all(targets_at_cpg_k_index_4(:,3) > neighbor_targets_at_cpg_k_index_2(:,3)) ,
            break
        end
    end

    % Place the neightbor tile CPG z-plane 1 at a set spacing from z-plane 2, or
    % hard against the lower limit if need be.
    neighbor_tile_new_k0_at_cpg_k_index_1 = max(0, neighbor_tile_new_k0_at_cpg_k_index_2-htop) ;
    neighbor_targets_at_cpg_k_index_1 = ...
        corrected_targets_for_single_cpg_k_plane(neighbor_tile_new_k0_at_cpg_k_index_1, ...
                                                 field_corrected_cpg_ij0s, ...
                                                 neighbor_affine_transform, ...
                                                 Fx_next_layer, ...
                                                 Fy_next_layer, ...
                                                 Fz_next_layer, ...
                                                 do_correct_targets) ;

    % Package up the targets for the neighbor tile for return                                              
    neighbor_targets_at_cpg_k_indices_1_and_2 = [ neighbor_targets_at_cpg_k_index_1 ; neighbor_targets_at_cpg_k_index_2 ] ;

    % Set the new neighbor tile CPG k values for return
    new_neighbor_tile_k0_from_cpg_k_index = ...
        [ neighbor_tile_new_k0_at_cpg_k_index_1 ; ...
          neighbor_tile_new_k0_at_cpg_k_index_2 ; ...
          old_neighbor_tile_k0_from_cpg_k_index(3) ; ...
          old_neighbor_tile_k0_from_cpg_k_index(4) ] ;

    % Make a first pass at the (self) tile CPG k values
    prototype_new_k0_from_cpg_k_index = ...
        [ old_k0_from_cpg_k_index(1) ; old_k0_from_cpg_k_index(2) ; default_k0_at_cpg_k_index_3 ; default_k0_at_cpg_k_index_4 ] ;

    % Fix any ordering changes that might have happened  because of knn search for
    % this tile (the self tile)
    % ALT: Don't we need to re-compute the targets if we're changing these?
    new_k0_from_cpg_k_index = prototype_new_k0_from_cpg_k_index ;
    if prototype_new_k0_from_cpg_k_index(2) >= prototype_new_k0_from_cpg_k_index(3) ,
        % make sure there is enough space with the first control point
        if prototype_new_k0_from_cpg_k_index(1) < prototype_new_k0_from_cpg_k_index(3)-2 ,
            new_k0_from_cpg_k_index(2) = prototype_new_k0_from_cpg_k_index(3) - 1 ;
        else
            if prototype_new_k0_from_cpg_k_index(3) > 3 ,
                new_k0_from_cpg_k_index(2) = prototype_new_k0_from_cpg_k_index(3) - 1 ;
                new_k0_from_cpg_k_index(1) = prototype_new_k0_from_cpg_k_index(3) - 2 ;
            end
        end
    end
end


