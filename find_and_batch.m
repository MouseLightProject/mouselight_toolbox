function find_and_batch(...
        base_folder_path, ...
        is_batch_input_predicate, ...
        batch_function, ...
        varargin)
    if do_these_look_like_key_value_pairs(varargin) ,
        [do_submit, do_try, submit_host_name, maximum_running_slot_count, slots_per_job, bsub_options, ...
         max_depth, predicate_extra_args, batch_function_extra_args,folder_predicate_function] = ...
            parse_keyword_args(...
            varargin, ...
            'do_submit', true, ...
            'do_try', true, ...
            'submit_host_name', '', ...
            'maximum_running_slot_count', 400, ...
            'slots_per_job', 1, ...
            'bsub_options', '', ...
            'max_depth', inf, ...
            'predicate_extra_args', cell(1,0), ...
            'batch_function_extra_args', cell(1,0), ...
            'folder_predicate_function', @(folder_path, depth)(true)) ;
    else
        % Assume args are in legacy "format"
        do_submit = varargin{1} ;
        do_try = varargin{2} ;
        submit_host_name = varargin{2} ;
        maximum_running_slot_count = varargin{3} ;
        slots_per_job = varargin{4} ;
        bsub_options = varargin{5} ;
        max_depth = inf ;
        predicate_extra_args = varargin(6:end) ;
        batch_function_extra_args = varargin(6:end) ;
    end
    find_and_batch_core(...
        base_folder_path, ...
        is_batch_input_predicate, ...
        batch_function, ...
        do_submit, ...
        do_try, ...
        submit_host_name, ...
        maximum_running_slot_count, ...
        slots_per_job, ...
        bsub_options, ...
        max_depth, ...
        predicate_extra_args, ...
        batch_function_extra_args, ...
        folder_predicate_function) ;    
end


function find_and_batch_core(...
        base_folder_path, ...
        is_batch_input_predicate, ...
        batch_function, ...
        do_submit, ...
        do_try, ...
        submit_host_name, ...
        maximum_running_slot_count, ...
        slots_per_job, ...
        bsub_options, ...
        max_depth, ...
        predicate_extra_args, ...
        batch_function_extra_args, ...
        folder_predicate_function)
    bqueue = bqueue_type(do_submit, do_try, maximum_running_slot_count, [], submit_host_name) ;
    find_and_batch_helper_bang(bqueue, ...
                               slots_per_job, ...
                               bsub_options, ...
                               base_folder_path, ...
                               is_batch_input_predicate, ...
                               batch_function, ...
                               max_depth, ...
                               predicate_extra_args, ...
                               batch_function_extra_args, ...
                               folder_predicate_function, ...
                               0) ;
    fprintf('Waiting for %d find_and_batch %s() jobs to finish...\n', bqueue.queue_length(), func2str(batch_function)) ;
    job_statuses = bqueue.run() ;
    if all(job_statuses==1) ,
        fprintf('All %d %s() batch jobs completed without errors.\n', bqueue.queue_length(), func2str(batch_function)) ;
    else
        fprintf('All %d %s() batch jobs exited, but some had errors.\n', bqueue.queue_length(), func2str(batch_function)) ;
        had_error = (job_statuses==-1) ;
        job_ids = bqueue.job_ids ;
        bad_job_ids = job_ids(had_error) ;
        fprintf('Job ids with errors: %s\n', mat2str(bad_job_ids)) ;
        error('All %d %s() batch jobs exited, but some had errors.\n', bqueue.queue_length(), func2str(batch_function)) ;
    end
end



function find_and_batch_helper_bang(bqueue, ...
                                    slots_per_job, ...
                                    bsub_options, ...
                                    base_folder_path, ...
                                    is_batch_input_predicate, ...
                                    batch_function, ...
                                    max_depth, ...
                                    predicate_extra_args, ...
                                    batch_function_extra_args, ...
                                    folder_predicate_function, ...
                                    depth)
    [file_names, is_file_a_folder] = simple_dir(base_folder_path) ;
    file_count = length(file_names) ;
    for i = 1 : file_count ,
        file_name = file_names{i} ;
        is_this_file_a_folder = is_file_a_folder(i) ;
        file_path = fullfile(base_folder_path, file_name) ;
        if is_this_file_a_folder ,
            % if a folder, recurse if not too deep
            do_descend = (depth < max_depth) && feval(folder_predicate_function, file_path, depth) ;
            if do_descend ,
                find_and_batch_helper_bang(...
                    bqueue, ...
                    slots_per_job, ...
                    bsub_options, ...
                    file_path, ...
                    is_batch_input_predicate, ...
                    batch_function, ...
                    max_depth, ...
                    predicate_extra_args, ...
                    batch_function_extra_args, ...
                    folder_predicate_function, ...
                    depth+1) ;
            end
        else
            if feval(is_batch_input_predicate, file_path, predicate_extra_args{:}) ,
                bqueue.enqueue(slots_per_job, ...
                               [], ...
                               bsub_options, ...
                               batch_function, ...
                               file_path, ...
                               batch_function_extra_args{:}) ;
            end
        end
    end    
end
